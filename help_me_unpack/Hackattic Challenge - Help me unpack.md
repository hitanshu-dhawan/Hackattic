---
url: https://hackattic.com/challenges/help_me_unpack
code_url: https://github.com/hitanshu-dhawan/Hackattic
---

# Help me unpack

The challenge is to receive bytes and extract some numbers from those bytes.

Connect to the problem endpoint, grab a `base64`-encoded pack of bytes, unpack the required values from it and send them back.

The pack contains, always in the following order:

- a regular `int` (signed), to start off
- an `unsigned int`
- a `short` (signed) to make things interesting
- a `float` because floating point is important
- a `double` as well
- another `double` but this time in big endian (network byte order)

In case you're wondering, we're using 4 byte `ints`, so everything is in the context of a 32-bit platform.

Extract those numbers from the byte string and send them back to the solution endpoint for your reward. See the solution section for a description of the expected JSON format.

##### Getting the problem set

`GET /challenges/help_me_unpack/problem?access_token=<access_token>`

Problem JSON format will be in the following format:

- `bytes`: base64 encoded bytes that you have to unpack

##### Submitting a solution

`POST /challenges/help_me_unpack/solve?access_token=<access_token>`

Solution JSON structure:

- `int`: the signed integer value
- `uint`: the unsigned integer value
- `short`: the decoded `short` value
- `float`: surprisingly, the float value
- `double`: the double value - shockingly
- `big_endian_double`: you get the idea by now!

To make things easier, the response will usually include info about which value you got wrong and what was the expected value.

##### Why this challenge?

This challenge is actually inspired in part by [the Redis one](https://hackattic.com/challenges/the_redis_one) challenge, where reading things from raw bytes is sort of necessary. I also figured `h^` really needed a simple, first-timer friendly challenge with a simple premise, and here it is!

By the way, I was always slightly fascinated by how floating point _things_ are stored. The IEEE754 format is actually really, really **neat** - it's just that people in general suck at explaning it (jumping straight to math, which is lazy). If you want to read more into it, I can wholeheartedly recommend [floating point visually explained](http://fabiensanglard.net/floating_point_visually_explained/). It's a great piece.

---
# Solution

```python
import os
import requests
import base64
from struct import unpack

# Get access token from environment variables
ACCESS_TOKEN = os.getenv("ACCESS_TOKEN")

# API endpoints
PROBLEM_URL = f"https://hackattic.com/challenges/help_me_unpack/problem?access_token={ACCESS_TOKEN}"
SOLVE_URL = f"https://hackattic.com/challenges/help_me_unpack/solve?access_token={ACCESS_TOKEN}" + "&playground=1"

# Fetch the problem statement
response = requests.get(PROBLEM_URL)
data = response.json()

# Decode base64-encoded bytes
encoded_bytes = data["bytes"]
byte_data = base64.b64decode(encoded_bytes)

# Print the byte data
print("Byte data:", byte_data)

# Unpacking the values
signed_int = unpack("<i", byte_data[:4])[0]           # 4 bytes (little-endian, signed int)
unsigned_int = unpack("<I", byte_data[4:8])[0]        # 4 bytes (little-endian, unsigned int)
signed_short = unpack("<h", byte_data[8:10])[0]       # 2 bytes (little-endian, signed short)
float_value = unpack("<f", byte_data[12:16])[0]       # 4 bytes (little-endian, float)
double_value = unpack("<d", byte_data[16:24])[0]      # 8 bytes (little-endian, double)
big_endian_double = unpack(">d", byte_data[24:32])[0] # 8 bytes (big-endian, double)

# Prepare solution payload
solution_payload = {
    "int": signed_int,
    "uint": unsigned_int,
    "short": signed_short,
    "float": float_value,
    "double": double_value,
    "big_endian_double": big_endian_double
}

# Print the unpacked values
print("Unpacked values:")
print("Signed int (4 bytes, little-endian):", signed_int)
print("Unsigned int (4 bytes, little-endian):", unsigned_int)
print("Signed short (2 bytes, little-endian):", signed_short)
print("Float (4 bytes, little-endian):", float_value)
print("Double (8 bytes, little-endian):", double_value)
print("Big-endian double (8 bytes, big-endian):", big_endian_double)

# Submit the solution
solve_response = requests.post(SOLVE_URL, json=solution_payload)
result = solve_response.json()

# Print the result
print("Solution submitted. Response:", result)
```

-- Generated by ChatGPT.

This Python code is using the `struct.unpack` function to extract multiple values from a binary data buffer (`byte_data`). Let's break it down step by step.

### **Understanding `struct.unpack`**

- `unpack(format, buffer)` is used to convert binary data (`buffer`) into Python data types based on the given `format` string.
- The format string specifies:
    - **Byte order**:
        - `<` → Little-endian (least significant byte first)
        - `>` → Big-endian (most significant byte first)
    - **Data type**:
        - `i` → 4-byte signed integer
        - `I` → 4-byte unsigned integer
        - `h` → 2-byte signed short
        - `f` → 4-byte floating point (IEEE 754 single-precision)
        - `d` → 8-byte floating point (IEEE 754 double-precision)

### **Code Breakdown**

```python
signed_int = unpack("<i", byte_data[:4])[0]
```

- Extracts the first **4 bytes** (`byte_data[:4]`).
- Interprets it as a **little-endian signed 4-byte integer** (`<i`).
- Example: `b'\xFF\xFF\xFF\xFF'` → `-1` (assuming two’s complement representation).

---

```python
unsigned_int = unpack("<I", byte_data[4:8])[0]
```

- Extracts the next **4 bytes** (`byte_data[4:8]`).
- Interprets it as a **little-endian unsigned 4-byte integer** (`<I`).
- Example: `b'\xFF\xFF\xFF\xFF'` → `4294967295` (since it's unsigned).

---

```python
signed_short = unpack("<h", byte_data[8:10])[0]
```

- Extracts **2 bytes** (`byte_data[8:10]`).
- Interprets it as a **little-endian signed short (2-byte integer)** (`<h`).
- Example: `b'\xFF\x7F'` → `32767`.

---

```python
float_value = unpack("<f", byte_data[12:16])[0]
```

- Extracts **4 bytes** (`byte_data[12:16]`).
- Interprets it as a **little-endian 4-byte floating point number** (`<f`).
- Example: `b'\x00\x00\x80\x3F'` → `1.0` (IEEE 754 representation).

---

```python
double_value = unpack("<d", byte_data[16:24])[0]
```

- Extracts **8 bytes** (`byte_data[16:24]`).
- Interprets it as a **little-endian 8-byte double-precision float** (`<d`).
- Example: `b'\x00\x00\x00\x00\x00\x00\xF0\x3F'` → `1.0` (IEEE 754 double representation).

---

```python
big_endian_double = unpack(">d", byte_data[24:32])[0]
```

- Extracts **8 bytes** (`byte_data[24:32]`).
- Interprets it as a **big-endian 8-byte double-precision float** (`>d`).
- This means the most significant byte is first.
- Example: `b'\x3F\xF0\x00\x00\x00\x00\x00\x00'` → `1.0`.

---

### **Summary**

This code reads binary data (`byte_data`) and extracts:

1. A **signed 4-byte integer** (little-endian).
2. An **unsigned 4-byte integer** (little-endian).
3. A **signed 2-byte short integer** (little-endian).
4. A **4-byte float** (little-endian, IEEE 754).
5. An **8-byte double** (little-endian, IEEE 754).
6. Another **8-byte double**, but in **big-endian format**.

---
# Resources

- https://docs.python.org/3/library/struct.html#format-characters


#Hackattic
