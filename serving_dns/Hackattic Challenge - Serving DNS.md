---
url: https://hackattic.com/challenges/serving_dns
code_url: https://github.com/hitanshu-dhawan/Hackattic
---

# Serving DNS

OK, it's time for you do to some real work. Let's see if you can set up a DNS server. Fetch the problem set for this challenge, take a good look at the required DNS records it contains and get to work - set up a publicly-accessible DNS server containing those records. When you're done, `POST` back the IP and port, and we'll do a quick check to make sure all the stuff we asked for is there.

You have one minute counting from the time you ask for problem set. It's not too much, but after you've done the initial setup it should be enough to even copy-paste the settings to your zone files.

##### Getting the problem set

`GET /challenges/serving_dns/problem?access_token=<access_token>`

Problem JSON structure is simple:

- `records`: a list of records your DNS server should know about

##### Submitting a solution

`POST /challenges/serving_dns/solve?access_token=<access_token>`

As solution, submit a JSON with the IP address and port of the DNS server you want us to interrogate.

- `dns_ip`: the IP of your DNS server
- `dns_port`: the port of your DNS server

We'll run a really quick check for the records we asked and send back a response.

##### Background

The DNS infrastructure is nothing short of amazing. It gets bonus points because it handles crazy amounts of traffic, all while being nearly transparent to the users. And since it's an old beast, you're bound to run into forgotten specs or options, memories of a world long gone. It's a beautiful trip.

Fun fact: the IPv6 you're asked to set comes from [RFC6666](https://tools.ietf.org/html/rfc6666). That `TXT` value may also be interesting.

---
# Solution

-- Generated by ChatGPT.

### Explanation of the DNS Server in the Python Code

This code implements a simple DNS server using the `dnslib` library. Below is a detailed breakdown of how the DNS server component works.

## **1. Fetching DNS Records**

```python
records = fetch_dns_records()
```

- Before starting the DNS server, it fetches DNS records from an external source (the function `fetch_dns_records()` is assumed to return a list of DNS records, but its implementation is not shown).
- These records are used to resolve DNS queries.

## **2. Creating a Custom DNS Resolver**

```python
def create_dns_resolver(records):
```

- This function defines a `CustomResolver` class that processes incoming DNS requests.

### **Inside `CustomResolver`:**

```python
class CustomResolver:
    def __init__(self):
        super().__init__()
        self.records = records
```

- The constructor initializes the resolver with the provided DNS records.

#### **Handling DNS Queries**

```python
def resolve(self, request, handler):
```

- This method processes incoming DNS queries.
- It extracts the requested **domain name** and **query type**.

```python
domain = str(request.q.qname).rstrip('.')  # Domain name
qtype = request.q.qtype  # Query type (e.g., A, AAAA, TXT)
```

#### **Matching Records**

```python
matching_records = []
for record in self.records:
    record_name = record['name']
    if domain == record_name:
        matching_records.append(record)
    elif record_name.startswith('*.'):
        wildcard_suffix = record_name[2:]
        if domain.endswith(wildcard_suffix):
            matching_records.append(record)
```

- This block finds DNS records that match the requested domain.
- It supports **exact matches** and **wildcard domains** (e.g., `*.example.com`).

#### **Building the DNS Response**

```python
for record in matching_records:
    try:
        record_type = record['type']
        record_data = record['data']
        rr_data = None
```

- Extracts the **record type** and **record data**.

```python
if record_type == 'A' and qtype == QTYPE.A:
    rr_data = A(record_data)
elif record_type == 'AAAA' and qtype == QTYPE.AAAA:
    rr_data = AAAA(record_data)
elif record_type == 'TXT' and qtype == QTYPE.TXT:
    rr_data = TXT(record_data)
elif record_type == 'RP' and qtype == QTYPE.RP:
    rr_data = RP(record_data)
```

- Checks if the record type matches the query type and converts it to the appropriate DNS record format.

```python
if rr_data:
    rr = RR(rname=domain, rtype=qtype, rdata=rr_data)
    reply.add_answer(rr)
```

- If a matching record is found, it is added to the DNS response.

## **3. Starting the DNS Server**

```python
def start_dns_server(records, address, port):
```

- This function initializes and starts the DNS server.

```python
resolver = create_dns_resolver(records)
dns_server = DNSServer(resolver, address=address, port=port)
```

- It creates a `DNSServer` using `dnslib.DNSServer`, binding it to a specific IP (`0.0.0.0` for all interfaces) and port (`2053` in this case).

```python
dns_server.start_thread()
```

- Starts the DNS server in a separate thread so that it can run in the background.

## **4. Running the Server**

```python
while True:
    pass
```

- Keeps the server running indefinitely.

```python
except KeyboardInterrupt:
    print("Shutting down server...")
    dns_server.stop()
```

- Stops the server gracefully when interrupted.

## **Summary**

- This Python program creates a **custom DNS server** that listens for queries on port `2053`.
- It **fetches predefined DNS records** and uses a **custom resolver** to handle domain name resolution.
- The server supports **wildcard domain handling** and **multiple DNS record types** (A, AAAA, TXT, RP).
- It runs in a **background thread** and can be stopped gracefully.

---
# Resources

- [[000 - Build your own DNS server]]
- https://pypi.org/project/dnslib/
- https://www.rfc-editor.org/rfc/rfc1035#section-4


#Hackattic
