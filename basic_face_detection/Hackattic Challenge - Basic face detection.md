---
url: https://hackattic.com/challenges/basic_face_detection
code_url: https://github.com/hitanshu-dhawan/Hackattic
---

# Basic face detection

Hit the problem endpoint, grab the `image_url` value. The link expires in 5 seconds.

In the linked image you'll see a `8x8` grid of tiles, some of which contain faces.

Your task is straightforward: detect which tiles have a face in them. The result should be a list of two-element lists indictating which tiles successfuly went through face detection.

Use zero based indexing for `row` and `column`. So in a `8x8` tile grid, top left image is `[0, 0]`, bottom right will be `[7, 7]`.

For example, if there's only one face-containing tile and it's in the second row, fifth column, the answer would be `[[1, 4]]`.

##### Getting the problem set

`GET /challenges/basic_face_detection/problem?access_token=<access_token>`

Problem JSON format will be in the following format:

- `image_url`: a one-time URL of the image you have to analyze

##### Submitting a solution

`POST /challenges/basic_face_detection/solve?access_token=<access_token>`

Solution JSON structure:

- `face_tiles`: a list of `[row, column]` pairs (as two element lists) pointing to the tiles that have faces in them (e.g. `[[1, 3], [4, 5]]`)

Remember to use integers as values, not strings.

##### Why this challenge?

Face detection is nowadays front-and-center in so many places. It still seems like magic to a lot of people, though - and it's really not! This challenge is your excuse for getting into this stuff.

By the way - in case you're wondering - a green apple is not a face.

---
# Solution

-- Generated by ChatGPT.

```python
FACE_CASCADE = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")
```

initializes a **Haar cascade classifier** using OpenCV to detect **frontal human faces** in images or video streams.

1. **Loads a pre-trained model** (`haarcascade_frontalface_default.xml`), which contains patterns to recognize faces.
2. **Scans an image using a sliding window** and detects regions that match the learned facial features.
3. **Returns bounding boxes** around detected faces.

This method is simple, but **Deep Learning-based detectors (like OpenCV's DNN module)** provide more accurate results.

---

```python
def detect_faces(image):
    """Detect faces in the 8x8 grid and return their coordinates."""
    print("[INFO] Detecting faces in the 8x8 grid...")
    h, w, _ = image.shape
    tile_h, tile_w = h // 8, w // 8
    face_tiles = []
    
    for i in range(8):
        for j in range(8):
            tile = image[i * tile_h: (i + 1) * tile_h, j * tile_w: (j + 1) * tile_w]
            gray_tile = cv2.cvtColor(tile, cv2.COLOR_BGR2GRAY)
            faces = FACE_CASCADE.detectMultiScale(gray_tile, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))
            
            if len(faces) > 0:
                print(f"[DEBUG] Face detected at tile: ({i}, {j})")
                face_tiles.append([i, j])
    
    print(f"[INFO] Total faces detected: {len(face_tiles)}")
    return face_tiles
```

This function, `detect_faces(image)`, is designed to scan an 8×8 grid over an image and detect faces in each grid tile. Here’s how it works step by step:

### **1. Function Purpose**

- It takes an image as input.
- Splits the image into an 8×8 grid (i.e., 64 tiles).
- Detects faces in each tile using OpenCV’s Haar Cascade classifier (`FACE_CASCADE`).
- Returns a list of grid coordinates where faces were detected.

---

### **2. Step-by-Step Breakdown**

#### **a) Extract Image Dimensions**

```python
h, w, _ = image.shape
```

- `h` → Height of the image.
- `w` → Width of the image.
- `_` → Number of channels (typically 3 for BGR images).

#### **b) Compute Tile Size**

```python
tile_h, tile_w = h // 8, w // 8
```

- `tile_h` → Height of each grid tile (`total height / 8`).
- `tile_w` → Width of each grid tile (`total width / 8`).

#### **c) Initialize Face Tile Storage**

```python
face_tiles = []
```

- Stores the `(row, col)` positions of tiles where faces are detected.

#### **d) Loop Through 8×8 Grid**

```python
for i in range(8):  
    for j in range(8):
```

- Loops through **8 rows (`i`)** and **8 columns (`j`)**.

#### **e) Extract Each Tile**

```python
tile = image[i * tile_h: (i + 1) * tile_h, j * tile_w: (j + 1) * tile_w]
```

- Extracts a **tile** of size `(tile_h × tile_w)` from the image.

#### **f) Convert Tile to Grayscale**

```python
gray_tile = cv2.cvtColor(tile, cv2.COLOR_BGR2GRAY)
```

- Converts the tile to grayscale for face detection.

#### **g) Detect Faces Using Haar Cascade**

```python
faces = FACE_CASCADE.detectMultiScale(gray_tile, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))
```

- Uses `FACE_CASCADE.detectMultiScale()` to detect faces in the grayscale tile.
    - `scaleFactor=1.1` → Scales image slightly to detect faces at different sizes.
    - `minNeighbors=5` → Minimum neighbors needed to confirm a face.
    - `minSize=(30, 30)` → Minimum face size to be detected.

#### **h) Store Grid Positions of Detected Faces**

```python
if len(faces) > 0:
    print(f"[DEBUG] Face detected at tile: ({i}, {j})")
    face_tiles.append([i, j])
```

- If faces are detected in the tile, their `(row, col)` position is **appended to `face_tiles`**.

#### **i) Print Total Faces Detected**

```python
print(f"[INFO] Total faces detected: {len(face_tiles)}")
```

- Displays the total number of tiles where faces were detected.

#### **j) Return Face Coordinates**

```python
return face_tiles
```

- Returns a **list of grid coordinates** (row, col) where faces were found.

---

### **3. Example Output**

If the function detects faces in tiles `(2, 3)`, `(4, 5)`, and `(7, 1)`, it might print:

```
[INFO] Detecting faces in the 8x8 grid...
[DEBUG] Face detected at tile: (2, 3)
[DEBUG] Face detected at tile: (4, 5)
[DEBUG] Face detected at tile: (7, 1)
[INFO] Total faces detected: 3
```

And return:

```python
[[2, 3], [4, 5], [7, 1]]
```

---

### **4. Key Takeaways**

- **Divides the image** into an **8×8 grid**.
- **Detects faces in each tile** using OpenCV's Haar cascade.
- **Returns the (row, col) positions** of detected faces in the grid.
- This method helps in localizing face positions efficiently across an image.

---
# Resources

- https://medium.com/geeky-bawa/face-identification-using-haar-cascade-classifier-af3468a44814
- https://medium.com/geeky-bawa/face-detection-using-haar-cascade-classifier-in-python-using-opencv-97873fbf24ec


#Hackattic
